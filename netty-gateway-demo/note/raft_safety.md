# raft 安全性
看网上谈到raft safety的时候，都会上这张图
![](raft_safety.jpg)

作者：呆呆
链接：https://zhuanlan.zhihu.com/p/33816607

Leader 在备份当前 Term 的日志记录时，在成功备份至集群大多数节点上后 Leader 即可认为该日志记录已提交。
但如果 Leader 在日志记录备份至大多数节点之前就崩溃了，后续的 Leader 会尝试继续备份该日志。
然而，此时的 Leader 即使在将该日志备份至大多数节点上后都无法立刻得出该日志已提交的结论。


考虑上图这种情形。

1. 在时间点 (a) 时，S1 是 Leader，并把 (TermID=2, index=2) 的日志记录备份到了 S2 上。

2. 到了时间点 (b) 时，S1 崩溃，S5 收到 S3、S4、S5 的选票，被选为 Leader，
    并从客户端处接收到日志记录 (TermID=3, index=2)。
    
3. 在时间点 (c) 时，S5 崩溃，S1 重启，被选举为 Leader，并继续将先前没有备份的日志记录 
    (TermID=2, index=2) 备份到其他节点上。即便此时 S1 顺利把该日志记录备份到集群大多数节点上，
    它仍然不能认为该日志记录已被安全提交。
    
考虑此时 S1 崩溃，S5 将可以收到来自 S2、S3、S4、S5 的选票，成为 Leader
（其最后一个日志记录的 Term ID 是 3，大于 2），进入情形 (d)：

此时 S5 会继续把日志记录 (TermID=3, index=2) 备份到其他节点上，覆盖掉原本已经备份
至大多数节点的日志记录 (TermID=2, index=2)。【这个是需要杜绝的情况】

然而，如果在时间点 (c) S1 成为 Leader 后，**同样将当前 Term 的最新日志记录**
(TermID=4, index=3) 备份出去并提交，就会进入情形 (e)，此时 S5 便无法再被选举为 Leader。

因此，解决该问题的关键在于**在备份旧 Term 的日志时也要把当前 Term 最新的日志一并分发出去**。
由此，Raft 只会在备份当前 Term 的日志记录时才会通过计数的方式来判断该日志记录是否已被提交；
一旦该日志记录完成提交，根据前面提及的 Log Matching 性质，Leader 就能得出之前的日志记录
也已被提交。

由此，我们便实现了前面提及的 Leader Completeness 性质。文中 5.4.3 节有完整的证明过程，
感兴趣的读者可自行查阅。

> 上面的例子只是为了说明 Commit当前term的Log时将之前的所有Log都顺序Commit，
> 可以保证数据的安全性,这样复制大多数的数据不会被覆盖，实际情况c的情况不会出现，
> 即leader s1不会复制term2的日志到s3。而是如同(e)描述的情况，通过复制-提交 term4的日志顺便提交term2的日志。
> 如果term4的日志提交成功，那么term2的日志也一定提交成功，此时即使s1 crash，s5也不会重新当选

下面可以证明：

## 验证复盘
按照上述raft限制的性质：
1. Leader只能对自己本Term的提案采用统计大多数的方式Commit
2. Commit的Log之前的所有Log都顺序Commit

进行上面crash复盘，验证安全性。

1. 在时间点 (a) 时，S1 是 Leader，并把 (TermID=2, index=2,v=2) 的日志记录备份到了 S2 上。因为2没有被复制给大多数，暂时算无效旧数据

2. 到了时间点 (b) 时，S1 崩溃，S5 收到 S3、S4、S5 的选票，被选为 Leader。
    并从客户端处接收到日志记录 (TermID=3, index=2，v=3)。
    
3. 在时间点 (c) 时，S5 崩溃，S1 重启，这个时候没有leader,超时选举前s2,s3,S4（TermID=3）而S1（TermId=2),无法通过preVote,无法选主，
    只有S2(TermID=3,index=2)的任期最大且有最多的log，被选为新leader，选为新leader，先发送空白请求
    ，让旧term的数据提交且同步到其他follower节点。

