# raft 安全性
看网上谈到raft safety的时候，都会上这张图
![](raft_safety.jpg)

作者：呆呆
链接：https://zhuanlan.zhihu.com/p/33816607

Leader 在备份当前 Term 的日志记录时，在成功备份至集群大多数节点上后 Leader 即可认为该日志记录已提交。
但如果 Leader 在日志记录备份至大多数节点之前就崩溃了，后续的 Leader 会尝试继续备份该日志。
然而，此时的 Leader 即使在将该日志备份至大多数节点上后都无法立刻得出该日志已提交的结论。


考虑上图这种情形。

1. 在时间点 (a) 时，S1 是 Leader，并把 (TermID=2, index=2) 的日志记录备份到了 S2 上。

2. 到了时间点 (b) 时，S1 崩溃，S5 收到 S3、S4、S5 的选票，被选为 Leader，
    并从客户端处接收到日志记录 (TermID=3, index=2)。
    
3. 在时间点 (c) 时，S5 崩溃，S1 重启，被选举为 Leader，并继续将先前没有备份的日志记录 
    (TermID=2, index=2) 备份到其他节点上。即便此时 S1 顺利把该日志记录备份到集群大多数节点上，
    它仍然不能认为该日志记录已被安全提交。
    
考虑此时 S1 崩溃，S5 将可以收到来自 S2、S3、S4、S5 的选票，成为 Leader
（其最后一个日志记录的 Term ID 是 3，大于 2），进入情形 (d)：

此时 S5 会继续把日志记录 (TermID=3, index=2) 备份到其他节点上，覆盖掉原本已经备份
至大多数节点的日志记录 (TermID=2, index=2)。

然而，如果在时间点 (c) S1 成为 Leader 后，同样将当前 Term 的最新日志记录
(TermID=4, index=3) 备份出去并提交，就会进入情形 (e)，此时 S5 便无法再被选举为 Leader。

因此，解决该问题的关键在于**在备份旧 Term 的日志时也要把当前 Term 最新的日志一并分发出去**。
由此，Raft 只会在备份当前 Term 的日志记录时才会通过计数的方式来判断该日志记录是否已被提交；
一旦该日志记录完成提交，根据前面提及的 Log Matching 性质，Leader 就能得出之前的日志记录
也已被提交。

由此，我们便实现了前面提及的 Leader Completeness 性质。文中 5.4.3 节有完整的证明过程，
感兴趣的读者可自行查阅。

# 验证复盘
按照上述raft限制的性质：
1. Leader只能对自己本Term的提案采用统计大多数的方式Commit
2. Commit的Log之前的所有Log都顺序Commit

进行上面crash复盘，验证安全性。

1. 在时间点 (a) 时，S1 是 Leader，并把 (TermID=2, index=2) 的日志记录备份到了 S2 上。

2. 到了时间点 (b) 时，S1 崩溃，S5 收到 S3、S4、S5 的选票，被选为 Leader，
    并从客户端处接收到日志记录 (TermID=3, index=2)。

