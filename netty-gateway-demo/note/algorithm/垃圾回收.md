
增量式垃圾回收思想
垃圾回收离不开STW，STW是Stop The World，指会暂停所有正在执行的用户线程/协程，进行垃圾回收的操作，
STW为垃圾对象的扫描和标记提供了必要的条件。

非增量式垃圾回收需要STW，在STW期间完成所有垃圾对象的标记，STW结束后慢慢的执行垃圾对象的清理。

增量式垃圾回收也需要STW，在STW期间完成部分垃圾对象的标记，然后结束STW继续执行用户线程，
一段时间后再次执行STW再标记部分垃圾对象，这个过程会多次重复执行，直到所有垃圾对象标记完成。


## Go垃圾回收主要原理
### 三色标记
为什么需要三色标记？

三色标记的目的，主要是利用Tracing GC做增量式垃圾回收，降低最大暂停时间。
原生Tracing GC只有黑色和白色，没有中间的状态，这就要求GC扫描过程必须一次性完成，得到最后的黑色和白色对象。
在前面增量式GC中介绍到了，这种方式会存在较大的暂停时间。

三色标记增加了中间状态灰色，增量式GC运行过程中，应用线程的运行可能改变了对象引用树，
只要让黑色对象直接引用白色对象，GC就可以增量式的运行，减少停顿时间。

什么是三色标记？

三色标记，望文生义可以知道它由3种颜色组成：

- 黑色 Black：表示对象是可达的，即使用中的对象，黑色是已经被扫描的对象。
- 灰色 Gary：表示被黑色对象直接引用的对象，但还没对它进行扫描。
- 白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。

**三色标记规则：黑色不能指向白色对象。即黑色可以指向灰色，灰色可以指向白色**。

### 三色标记主要流程：
1. 初始所有对象被标记为白色。
2. 寻找所有Root对象，比如被线程直接引用的对象，把Root对象标记为灰色。
3. 把灰色对象标记为黑色，并它们引用的对象标记为灰色。
4. 持续遍历每一个灰色对象，直到没有灰色对象。
5. 剩余白色对象为垃圾对象。


### ZGC原理
ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：

- [0~4TB) 对应Java堆
- [4TB ~ 8TB) 称为M0地址空间
- [8TB ~ 12TB) 称为M1地址空间
- [12TB ~ 16TB) 预留未使用
- [16TB ~ 20TB) 称为Remapped空间。

当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。
ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，
但这三个空间在同一时间有且只有一个空间有效。

ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。
“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。

**与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0~41位，而第42~45位存储元数据，第47~63位固定为0。**

ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。

**读屏障**
> 读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。
> 需要注意的是，**仅“从堆中读取对象引用”才会触发这段代码。**

### ZGC并发处理演示
接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：

- **初始化**：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。

- **并发标记阶段**：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。
    所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。
    如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。
    
- **并发转移阶段**：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。
    如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。

其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。
也即，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。

着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，
并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。

**从上面的流程，可以看出ZGC的原理和go的三色标记很像。MO,MI,REMAPPED 对应黑灰白。**

调优相关参考 **https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html**
ZGC运作过程

1. Concurrent Mark(并发标记)

    遍历对象图做可达性分析的阶段, 前后也要经过类似于G1, Shenandoah 的初始标记, 最终标记的短暂停顿。
    > 与G1, Shenandoah不同的是, ZGC的标记是在指针上而不是在对象上进行的, 标记阶段会更新染色指针中的Marked0、Marked1标志位。

2. Concurrent Prepare for Relocate(并发预备重分配)
    此阶段需要根据特定的查询条件统计出本次收集过程要清理哪些Region, 将这些Region组成重分配集(Relocation Set)。

3. Concurrent Relocate(并发重分配)

    是ZGC执行过程中的核心阶段, 此过程要把重分配集中的存活对象复制到新的Region上, 
   并为重分配集中的每个Region维护一个转发表(Forward Table), 记录从旧对象到新对象的转向关系。

    >由于染色指针的存在, ZGC能仅从引用上就明确得知一个对象是否处于重分配集之中。如果用户线程此时并发访问了位于重分配集中的对象, 
    这次访问将会被预置的内存屏障截获, 然后立即根据Region上的转发表记录将访问转发到新复制的对象上, 并同时修正该引用的值, 
    使其直接指向新对象, 此即为Self-Healing(自愈)[只有第一次访问旧对象会陷入转发]。

4. Concurrent Remap(并发重映射)

    修正整个堆中指向重分配集中旧对象的所有引用。
    重映射清理这些旧引用的主要目的是为了不变慢, 并不是很迫切。
    ZGC将并发重映射阶段要做的工作, 合并到了下一次垃圾收集循环中的并发标记阶段里去完成, 从而节省了一次遍历对象图的开销。

ZGC是一款优秀的垃圾收集器，它借鉴了Pauseless GC，也似乎在朝着C4 GC的方向发展——引入分代思想。

ZGC卓越的表现，让我们开发者看到了商用级别的GC“飞入寻常百姓家”的希望，随着JDK的发展，我相信在未来的某一天，JVM调优这种反人类的操作将不复存在，底层的GC会自适应各种情况自动优化。

其他关联：
- 虚拟内存多重映射，linux是mmap系统调用
- pgc (Pauseless GC), zing gc,C4(Concurrent Continuously Compacting Collector)

- shenandoah gc