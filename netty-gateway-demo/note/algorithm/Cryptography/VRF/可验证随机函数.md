## 区块链中VRF的作用
在区块链系统中，共识算法很重要的一个职责，就是**确定哪个节点拥有记账权**。
在基于 POW 共识的区块链系统中，矿工通过不断的尝试来计算得出一个随机数，若能使得这个随机数小于指定的难度值便可获得记账权。

**有没有可能在没有挖矿的前提下，生成一个全网可验证的随机数呢**？VRF 就是干这个事儿的。
VRF 全称可验证的随机函数(verifiable random function)，可以说是哈希函数与非对称加密结合的产物。

通过哈希函数，我们可以生成一段信息的数字指纹，防止信息被攥改。但如果还要对信息来源进行验证，我们需要信息验证码 MAC。
也就是在进行哈希计算时除了本来的信息，在加上一个密码，但要在通信双方共享这个密码，才能对消息进行验证。
VRF 比 MAC 厉害的地方在于，通过与非对称加密结合，通信双方可以不知道对方私钥的情况下，也可以对消息完整性和消息来源进行验证。


VRF算法由一组三个加密函数组成：Keygen、Evaluate 以及 Verify。
- Keygen(r) → (VK, SK)：对任意随机输入，Keygen 产生一对非对称密钥对：验证密钥 VK（公钥） 和私钥 SK。
- Evaluate(SK, X) → (Y, ⍴)：求值函数 Evaluate 输入私钥 SK、消息 X，输出伪随机字符串 Y 和证明 ⍴。
- Verify(VK, X, Y, ⍴)→ 0/1： 验证函数 Verify 输入验证密钥 VK、消息 X 以及求值函数中的输出： 伪随机字符串 Y 和证明 ⍴。
  输出结果0/1：只有该函数验证了证明 ⍴ 是根据 X 生成的，且根据证明 ⍴ 可以推导出 Y，才会输出 1，
  也就是说该函数验证 X 与 Y 是否存在唯一的对应关系。
  
对于相同的密钥对以及消息 X 输入，VRF 只会产生唯一的伪随机字符串 Y 和证明 ⍴。因此：
1.  **输出 Y 是唯一的**，因此具有不可伪造或抵赖性。
  因为不可能通过给定的密钥对(VK, SK)和消息 X 产生不同的输出 Y 和证明 ⍴。
  
2.  **输出 Y 是伪随机的**，因此对于不知道证明 ⍴ 的第三方来说它看起来就是随机的、不可预测的。
    如果同时给出证明 ⍴，就很容易通过调用验证函数 Verify 来验证 Y。 
    即使在用户随意选择密钥对的情况下上述两个特性也会保持。
    因此，验证者可以在用户不公开私钥的情况下证明用户确实持有该私钥，也就是`零知识证明`。


具体流程是下面这样的：
1. 证明者生成一对密钥，PK、SK；// PK 是公钥，SK 是私钥
2. 证明者计算result = VRF_Hash（SK，info）；// 计算得出随机数，
3. 证明者计算proof = VRF_Proof（SK，info）；
4. 证明者把result和proof递交给验证者；
5. 验证者计算result = VRF_P2H（proof）是否成立，若成立，继续下面的步骤，否则中止；
6. 证明者把PK，info递交给验证者；
7. 验证者计算True/False = VRF_Verify(PK, info, proof) ，True表示验证通过，False表示验证未通过。


#### 举例说明一下
假设某公链网络用普通节点，有可能是这样的情况：
假设全网有 100 个节点，我想生成下一轮一个节点谁打包，我以某一轮的轮次（公共信息）作为输入，
然后随机输出的值必须要是在 1-100 之间的自然数（因为网络中只有 100 个节点）。
这就每一轮都选出了一个打包节点的人。

这里的问题是，由于输入对应的输出肯定是相同的，而输入是公开的，就使得每一轮的抽签结果变得可以被预知，
攻击者可以尝试控制这个过程或者攻击特定的节点。可是如果输入不公开的话，我们要怎么保证这个输入结果没有问题呢？
VRF 就用到了零知识证明，让结果`可验证`。

VRF 的方式是，让各个节点自己抽签，如果抽中了之后，大家可以很容易地验证这个结果确实是你生成的。
具体过程有可能是这样的：假设现在是 round 10（第 10 轮），节点们可能会轮流抽签，
以节点自己的私钥 + 一个全网都知道的随机数（比如是这轮的轮次 10）作为输入，生成了一个随机数（0-100）；
设置一个条件：100 个节点轮流抽签，谁先抽出来的随机数大于 10，就是这一轮的打包者。
假设 5 号节点抽到了 11，可是只有 5 号知道其他人不知道，因此他在广播这个随机的同时还需要广播一个零知识证明。
通过零知识证明，全网只需要通过 5 号的公钥就可以验证，接受 5 号为这轮打包者。