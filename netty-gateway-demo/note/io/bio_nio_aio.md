IO可以分为两个阶段:
- 第一阶段，判断有没有事件发生（或判断数据有没有准备好，或判断Socket是否就绪） 
- 第二阶段，在数据准备好以后，执行真正的读（或写）操作，将数据从内核空间拷贝到用户空间。

这几个阶段：

- 同步阻塞IO（BIO）：两个阶段的用户进程都阻塞。
  
- 同步非阻塞IO（NIO）：
  第一阶段没有阻塞，但是用户进程（或线程）必须不断的轮询，判断有没有Socket就绪，这时cpu疯狂被占用。
  第二阶段，数据拷贝的过程是阻塞的。所以，所有的同步过程，在第二阶段都是阻塞的，尽管这是非阻塞的调用。
  
- 多路复用：
  NIO的第一阶段没有阻塞，但是由用户线程不断轮询多个Socket有没有就绪。
  而多路复用把这件事情交给一个内核线程去处理，速度非常快。
  select和poll机制下，第一阶段是也是阻塞的。
  而epoll机制，用户线程除了要执行epoll_create，还要执行epoll_ctl和epoll_wait，所以是非阻塞的。
  在第二阶段，所有的多路复用IO都是阻塞的。所以，多路复用IO也是同步IO。
  
- 异步IO（AIO）：两个阶段都是非阻塞的。

原文链接：https://blog.csdn.net/qq_37555071/article/details/113932533