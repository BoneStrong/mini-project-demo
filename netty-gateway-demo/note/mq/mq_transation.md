## 事务消息
参考https://www.cnblogs.com/xuwc/p/13528678.html

### 场景
说到分布式事务，就会谈到那个经典的”账号转账”问题：2个账号，分布处于2个不同的DB，或者说2个不同的子系统里面，A要扣钱，B要加钱，如何保证原子性？

一般的思路都是通过消息中间件来实现“最终一致性”：A系统扣钱，然后发条消息给中间件，B系统接收此消息，进行加钱。

> 但这里面有个问题：A是先update DB，后发送消息呢？ 还是先发送消息，后update DB？

- 假设先update DB成功，发送消息网络失败，重发又失败，怎么办？ 
- 假设先发送消息成功，update DB失败。消息已经发出去了，又不能撤回，怎么办？

所以，这里下个结论： **只要发送消息和update DB这2个操作不是原子的，无论谁先谁后，都是有问题的**。

那这个问题怎么解决呢？？

假设消息中间件没有提供“事务消息”功能，比如你用的是Kafka。那如何解决这个问题呢？

解决方案如下： 
1. Producer端准备1张消息表，把update DB和insert message这2个操作，放在一个DB事务里面。

2. 准备一个后台程序，源源不断的把消息表中的message传送给消息中间件。失败了，不断重试重传。允许消息重复，但消息不会丢，顺序也不会打乱。

3. Consumer端准备一个判重表。处理过的消息，记在判重表里面。实现业务的幂等。但这里又涉及一个原子性问题：如果保证消息消费 + insert message到判重表这2个操作的原子性？

消费成功，但insert判重表失败，怎么办？
关于这个，在Kafka的源码分析系列，第1篇， exactly once问题的时候，有过讨论。
(消息幂等消费，服务端重复发消息，期待下次消费成功)

通过上面3步，我们基本就解决了这里**update db**和**发送网络消息**这2个操作的原子性问题。

但这个方案的一个缺点就是：
需要设计DB消息表，同时还需要一个后台任务，不断扫描本地消息。
导致消息的处理和业务逻辑耦合额外增加业务方的负担。
服务消费者和提供者需要支持幂等。

### rocket mq 事务消息
上面的方案就是著名的本地消息表方案，解决分布式事务。

rocket mq 事务消息的实现原理其实和本地消息表一致，不过是将本地消息表封装到了mq里面。
为了能解决分布式问题，同时又不和业务耦合，RocketMQ提出了“事务消息”的概念。
把消息的发送分成了2个阶段：Prepare阶段和确认阶段。

其实上面的2个步骤，被分解成3个步骤： 
- (1) 发送Prepared消息 
- (2) update DB 
- (3) 根据update DB结果成功或失败，Confirm或者取消Prepared消息。

可能有人会问了，前2步执行成功了，最后1步失败了怎么办？
这里就涉及到了RocketMQ的关键点：
 > RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？
 
也就是定义了一个checkListener，RocketMQ会回调此Listener，从而实现上面所说的方案。
和本地消息表对比，其实就是把“扫描消息表”这个事情，不让业务方做，而是消息中间件帮着做了。
至于消息表，其实还是没有省掉。因为消息中间件要询问发送方，事物是否执行成功，还是需要一个“变相的本地消息表”，记录事物执行状态。

实际实现：
1. RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址
    Producer向Broker发送1条类型为TransactionPreparedType的消息，Broker接收消息保存在CommitLog中，
    然后返回消息的queueOffset和MessageId到Producer，MessageId包含有commitLogOffset（即消息在CommitLog中的偏移量，通过该变量可以直接定位到消息本身），
    由于该类型的消息在保存的时候，**commitLogOffset没有被保存到consumerQueue中，此时客户端通过consumerQueue取不到commitLogOffset**，
    所以该类型的消息无法被取到，导致不会被消费。
2. 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态
    Producer端的TransactionExecuterImpl执行本地操作，返回本地事务的状态，然后发送一条类型为TransactionCommitType或者TransactionRollbackType的消息到Broker确认提交或者回滚，
    Broker通过Request中的commitLogOffset，获取到上面状态为TransactionPreparedType的消息（简称消息A），
    然后重新构造一条与消息A内容相同的消息B，设置状态为TransactionCommitType或者TransactionRollbackType，然后保存。
    其中TransactionCommitType类型的，会放commitLogOffset到consumerQueue中，TransactionRollbackType类型的，消息体设置为空，不会放commitLogOffset到consumerQueue中。

细心的你可能又发现问题了，如果确认消息发送失败了怎么办？
RocketMQ会定期扫描消息集群中的事物消息，这时候发现了Prepared消息，它会向消息发送者确认，Bob的钱到底是减了还是没减呢？
如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

#### 事务失败处理
可能有人又要说了，无论方案1，还是方案2，发送端把消息成功放入了队列，但消费端消费失败怎么办？

消费失败了，重试，还一直失败怎么办？是不是要自动回滚整个流程？

答案是人工介入。从工程实践角度讲，这种整个流程自动回滚的代价是非常巨大的，不但实现复杂，还会引入新的问题。比如自动回滚失败，又怎么处理？

对应这种极低概率的case，采取人工处理，会比实现一个高复杂的自动化回滚系统，更加可靠，也更加简单。

## saga事务
Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，有两种不同的方式来实现saga事务，最流行的两种方式是：

#### 一、 事件/编排Choreography
没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。

该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。
 
处理流程：

1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
2. 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
4. 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。
5. 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。

假设库存服务在事务过程中失败了。进行回滚：

库存服务产生PRODUCT_OUT_OF_STOCK_EVENT

订购服务和支付服务会监听到上面库存服务的这一事件：

①支付服务会退款给客户。

②订单服务将订单状态设置为失败。

- **优点**：事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，
  因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。
- **缺点**：
    1. 如果您在事务中不断添加额外步骤，则此方法可能会很快变得混乱，因为很难跟踪哪些服务监听哪些事件。
    2. 此外，它还可能在服务之间添加循环依赖，因为它们必须订阅彼此的事件。
    3. 最后，使用这种设计来实现测试将会非常棘手。为了模拟交易行为，您应该运行所有服务。
    
#### 二、 命令/协调orchestrator
中央协调器负责集中处理事件的决策和业务逻辑排序。

saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。
 
1. 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
2. OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。
3. OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。
4. OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。

OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。
如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。
当你有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。

**优点**：
- 避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。
- 集中分布式事务的编排。
    - 只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
    - 在添加新步骤时，事务复杂性保持线性，回滚更容易管理。
    - 如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。

**缺点**：
1.有在协调器中集中太多逻辑的风险，并最终导致智能协调器会告诉愚蠢的服务该做什么的架构，
    这不符合Martinfowler定义微服务应该是聪明的服务+哑巴或愚蠢的管道。
2. 另一个缺点是它会稍微增加基础设施的复杂性，因为您需要管理额外的服务。
3. 同时增加单点风险，协调器一旦出问题，全局影响。