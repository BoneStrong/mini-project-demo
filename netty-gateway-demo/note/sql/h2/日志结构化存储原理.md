# 日志结构化存储原理

通常，如果您正在设计存储系统（例如文件系统或数据库），则主要要考虑的问题之一就是如何将数据存储在磁盘上。您必须注意为要**存储的对象分配空间**，以及**存储索引数据**。您必须担心要扩展现有对象（例如，附加到文件）时会发生什么，并且必须**注意碎片化**（*当旧对象被删除而新对象被替换时会发生碎片*）。所有这些都增加了很多复杂性，并且解决方案通常是错误的或效率低下的。

**结构化日志存储**是一种解决所有这些问题的技术。它起源于1980年代的[“日志结构文件系统”](http://en.wikipedia.org/wiki/Log-structured_file_system)，但是最近，结构化日志存储被视为一种在数据库引擎中结构化存储的方式而得到越来越多的使用。在其原始文件系统应用程序中，它有一些缺点，因此无法广泛采用，但是，对于数据库引擎而言，这些问题不那么严重，并且结构化日志存储为数据库引擎带来了更多的优势，而不仅仅是易于存储管理。

顾名思义，**结构化日志存储系统的基本组织是日志**，即---仅追加的数据条目序列。每当有新数据要写入时，只需在日志末尾追加即可，而不是在磁盘上查找位置。通过对元数据（metadata）以相同方式处理，可以对数据建立索引：**元数据更新也将追加到日志中**。这看似效率低下，但**基于磁盘的索引结构（例如B树）通常非常宽泛，因此每次写入时我们需要更新的索引节点的数量通常很小**。

## 结构化日志存储的例子

### 初始情况

让我们看一个简单的例子。我们将从仅包含单个数据项和引用该数据项的索引节点的日志开始：

![结构化日志：单个数据和索引](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2GtRp2qlWvo1RQWw8v%2F-M2Gu8UNL8c9aOH5oykK%2Fimage.png?alt=media&token=bb9f78a0-2f77-4d1c-8e0e-81f0f8bb253c)

### 元素增加

到目前为止，一切都很好。现在，假设我们要添加第二个元素`Bar`。我们将新元素添加到日志末尾，然后更新索引条目，并将更新后的索引也添加到日志中：

![追加Bar数据](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2GuR-_HNOOoCWSQF7Z%2F-M2Gv48sZL75HGuXEa6A%2Fimage.png?alt=media&token=e4c7b91a-3270-4c8c-86d6-0495f7b22238)

原始索引条目（`Index`）仍在日志文件中，但不再使用：它已由新条目`Index2`代替，新条目`Index2`指的是`Foo`的原始未修改副本以及新条目`Bar`。当某人想要读取我们的文件系统时，它会找到索引的根节点，然后通过索引找到下级索引，最终找到数据（与基于磁盘的索引的任何其他系统中的一样）。

### 查找数据块

查找数据块，首先得寻找索引的根节点。想当然的方法是：只是看日志中的最后一块，因为我们写的最后一个节点始终是索引的根。

但是，这并不理想，因为**在尝试读取索引时，可能会有另一个线程在追加日志**。我们可以通过在单个数据块（例如，在日志文件的开头， 如下图的`BLOCK`数据块）中包含指向当前根节点的指针来避免这种情况。每当我们更新日志时，我们都会重写此数据块以确保它指向新的根节点。(⚠️为了简单的描述结构化日志存储的其他问题和优点，此处描述的`BLOCK`数据块，下文忽略。)

![指向索引根节点的数据块](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2H0eGhlilvYtvLkdDG%2F-M2H30MMPdlzMYHUVWAi%2Fimage.png?alt=media&token=02793785-18b6-450a-aa78-8c96e567776d)

读取正在写入的日志时，此时的结构化的日志存储可能如下， 即**日志文件的末尾已经不是索引根节点了，而是刚写好的数据块，索引块还未刷入磁盘，此时可以通过Block 块找到正确的索引根节点**：

![Read When Write](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2H0eGhlilvYtvLkdDG%2F-M2H46BuJE74T6gSdTZU%2Fimage.png?alt=media&token=3de8f224-00a6-485b-aa12-a05c8f94639e)

### 更新数据

接下来，让我们检查一下更新元素时会发生什么。假设我们修改Foo：

![img](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2H4WYYQ9rihWkwtIwl%2F-M2H5sT1pQbwSUgHWPnZ%2Fimage.png?alt=media&token=7a8fb6d0-0ff0-473e-a1b5-227f5011396b)

在日志末尾添加一个全新的Foo副本`Foo'`。然后，我们再次更新索引节点（在本示例中仅更新为`index3`），并将索引也写入日志的末尾。 **Foo的旧副本再次保留在日志中；只是更新索引不再引用它**。

您可能已经意识到该系统不是无限可持续的。在某些时候，我们将用完存储空间，所有**这些旧数据都占据了空间**。

**在文件系统中，可以通过将磁盘视为循环缓冲区并覆盖旧日志数据来解决**。发生这种情况时，仍然将仍然有效的数据简单地再次添加到日志中，就好像它们是新写入的一样，从而释放了要覆盖的旧副本。在常规文件系统中，这是我前面提到的缺点之一，其缺点在于：随着磁盘变满，文件系统需要花费越来越多的时间进行垃圾收集，并将数据写回到日志的开头。到80％已满时，文件系统几乎停止运转。

但是，如果您将日志结构化存储用于数据库引擎，那么这不是问题！我们在常规文件系统之上实现此功能，因此我们可以利用它来简化我们的处理数据库存储。**如果将数据库分成多个固定长度的块，那么当我们需要回收一些空间时，我们可以选择一个块，重写任何仍处于活动状态的数据，然后删除该块**。

上面的示例中的第一段开始显得有些稀疏，所以让我们这样做：

![磁盘碎片整理](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2H4WYYQ9rihWkwtIwl%2F-M2H89TUoSL-UQOvmX-3%2Fimage.png?alt=media&token=bc7be69b-d506-4175-a1e4-4ba5a54cca8d)

如上图所述，我们要做的就是获取现有的`Bar`副本并将其写入日志的末尾，然后是更新的索引节点。现在我们已经完成了，**第一个日志段完全是空的，可以删除**。

## 优缺点分析

与文件系统的方法相比，将数据库切分成多个固定长度的块具有多个优点。

我们不限于首先删除最旧的段：**如果中间段几乎为空，则可以选择对其进行垃圾回收**。这对于某些数据会长时间保留且某些数据会被重复覆盖的数据库特别有用：我们不想浪费太多时间来重写相同的未修改数据。对于何时进行垃圾收集，我们还具有更大的灵活性：我们通常可以等到某个段大部分已过时再进行垃圾收集，从而进一步减少了我们要做的额外工作量。

但是，这种方法对于数据库的优势还不止于此。为了保持事务的一致性，数据库通常使用“预写日志”或WAL（Write Ahead Log）。

当数据库要将事务保留到磁盘时，它首先将所有更改写入WAL，将所有更改刷新到磁盘，然后更新实际的数据库文件，提交事务。通过重新执行WAL中记录的更改，使数据库可以从崩溃中恢复。

但是，**如果使用日志结构化存储，则“预写日志”是数据库文件，因此我们只需要写入一次数据**。在恢复情况下，我们只需打开数据库，从最后记录的索引头开始，然后线性向前搜索，就可以从数据中重建所有丢失的索引更新。

利用上面的恢复方案，我们也可以进一步优化写入。无需每次写入都写入更新的索引节点，我们可以将它们缓存在内存中，并仅将它们定期写入磁盘（*根索引不能丢失，在内存中怎么保证不丢失？*）。我们的恢复机制将负责在崩溃中重建事务，只要我们提供某种方式将完成的事务与未完成的事务区分开即可。 

通过这种方法，备份也变得更加容易：可以**通过在完成备份后将每个新日志段复制到备份介质上来连续，增量地备份数据库。**要恢复，我们只需再次运行恢复过程。

该系统的最后一个主要优点涉及数据库中的**并发和事务语义**。为了提供事务一致性，大多数数据库使用复杂的锁系统来控制哪些进程可以在什么时间更新数据。根据所需的一致性级别，这可能涉及读取器采取锁定措施以确保数据在读取时不会被修改（即：读写冲突），以及写入器锁定数据以进行写入，并且即使写入率相对较低，如果发生足够的并发读取，也会导致性能显着下降（使用传统的读写锁机制，会导致读数据时，无法写入；等读请求结束后，获取写锁，开始写入，此时无法读取数据）。

通过[Multiversion Concurrency Control或MVCC](http://en.wikipedia.org/wiki/Multiversion_concurrency_control)解决上面的读写冲突问题。每当节点要从数据库读取时，它都会查找当前的根索引节点，并将该节点用于当前事务。**在基于日志的存储系统中，现有数据永远不会修改，因此该过程获取到的索引根节点就是数据库快照：并发事务不管做什么都无法改变对数据库的视图**。这样，可以实现无锁读取！

![读写无冲突并发](https://gblobscdn.gitbook.com/assets%2F-M2GqBlWzshFYJVkWcFH%2F-M2HbfKoMAY5zRFLtEzH%2F-M2He2reRHAzFCxF6RCh%2Fimage.png?alt=media&token=f9aa78cc-e897-4d4e-bc0a-4c9ea54bd2ed)