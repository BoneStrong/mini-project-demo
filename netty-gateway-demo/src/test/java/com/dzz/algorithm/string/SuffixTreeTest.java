package com.dzz.algorithm.string;

/**
 * @author zoufeng
 * @date 2020-8-5
 *
 * 后缀树
 * 和后缀数组的区别是所有的后缀串以树的形式构造
 * 比后缀数组简单还实用，- -！
 *
 * 后缀树和后缀数组的核心都是如何快速的构建出数据结构。
 * 应用的过程反而是简单的。
 *
 * 后缀树的应用
 * 一、最长公共前缀
 * 1、 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。
 * 思路：先将字符串数组排序，在比较第一个字符串与最后一个字符串的公共前缀即可
 * eg：["abcddd","abbddd","abccc"] ; ["abbddd","abccc"，"abcddd"],
 * 只需比较第一个字符串"abbddd"与最后一个字符串"abcddd"
 *
 * 3、
 *
 * 二、最长回文字符串。 转换城最长公共前缀问题
 * 找出给定字符串里的最长回文。例子：输入XMADAMYX。则输出MADAM。
 * 分析：
 * 思维的突破点在于考察回文的半径，而不是回文本身。
 * 所谓半径，就是回文对折后的字串。比如回文MADAM 的半径为MAD，半径长度为3，半径的中心是字母D。
 * 显然，最长回文必有最长半径，且两条半径相等。还是以MADAM为例，以D为中心往左，我们得到半径 DAM；
 * 以D为中心向右，我们得到半径DAM。二者肯定相等。因为MADAM已经是单词XMADAMYX里的最长回文，
 * 我们可以肯定从D往左数的字串 DAMX与从D往右数的子串DAMYX共享最长前缀DAM。
 * 而这，正是解决回文问题的关键。现在我们有后缀树，怎么把从D向左数的字串DAMX变成后缀呢？
 * 到这个地步，答案应该明显：把单词XMADAMYX翻转就行了。于是我们把寻找回文的问题转换成了寻找两坨后缀的LCA（最长公共前缀）的问题。
 * 当然，我们还需要知道 到底查询那些后缀间的LCA。
 * 这也简单，给定字符串S，如果最长回文的中心在i，那从位置i向右数的后缀刚好是S(i)，
 * 而向左数的字符串刚好是翻转S后得到的字符串S‘的后缀S'(n-i+1)。这里的n是字符串S的长度。有了这套直观解释，算法自然呼之欲出：
 * 预处理后缀树，使得查询LCA的复杂度为O(1)。这步的开销是O(N)，N是单词S的长度。
 * 对单词的每一位置i(也就是从0到N-1)，获取LCA(S(i), S(N-i+1)) 以及LCA(S(i+1), S(n-i+1))。
 * 查找两次的原因是我们需要考虑奇数回文和偶数回文的情况。这步要考察每坨i，所以复杂度是O(N)。
 * 找到最大的LCA，我们也就得到了回文的中心i以及回文的半径长度，自然也就得到了最长回文。总的复杂度O(n)。
 *
 * 三、查找字符串0是否在某段字符串S中
 * 方案：用S构造后缀树，按在trie中搜索字串的方法搜索o即可。
 * 原理：若o在S中，则o必然是S的某个后缀的前缀。
 *
 * 四、查找字符串0是在某段字符串S中的重复次数
 * 方案：用S+’$'构造后缀树，搜索T节点下的叶节点数目即为重复次数
 * 原理：如果T在S中重复了两次，则S应有两个后缀以T为前缀，重复次数就自然统计出来了
 *
 * 五、字符串S中的最长重复子串
 * 方案：原理同四，具体做法就是找到最深的非叶节点。
 * 这个深是指从root所经历过的字符个数，最深非叶节点所经历的字符串起来就是最长重复子串。
 * 为什么要非叶节点呢?因为既然是要重复，当然叶节点个数要>=2。
 *
 * 六、两个字符串S1，S2的最长公共部分
 * 方案：将S1#S2$作为字符串压入后缀树，找到最深的非叶节点，且该节点的叶节点既有 '#' 也有 '$'。
 * 解题的时候在构造数的过程中求解
 */
public class SuffixTreeTest {

    /*
     * 求多个字符串的最长公共字串
     * 比如字符串acdfg同akdfc的最长公共子串为df
     *
     * 使用后缀树
     * */
    public void testSuffixTree(){

    }
}
