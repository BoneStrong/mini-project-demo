package com.dzz.algorithm.dynamic;

import org.junit.Test;

/**
 * @author zoufeng
 * @date 2020-7-1
 * <p>
 * 背包问题变种
 *
 * 金明的预算方案
 * 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。
 * 更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 nn 元钱就行”。
 * 今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
 * <p>
 * 主件	附件
 * 电脑	打印机，扫描仪
 * 书柜	图书
 * 书桌	台灯，文具
 * 工作椅	无
 * <p>
 * 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、1 个或 2 个附件。
 * 附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 N 元。
 * 于是，他把每件物品规定了一个重要度，分为 5 等：用整数 1-5 表示，第 5 等最重要。
 * 他还从因特网上查到了每件物品的价格（都是10元的整数倍）。
 * 他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
 * <p>
 * 设第 j 件物品的价格为 v[j]，重要度为 w[j]，共选中了 k 件物品，编号依次为 j1,j2,…,jk，则所求的总和为：
 * <p>
 * 　　v[j1]×w[j1]+v[j2]×w[j2]+ …+v[jk]×w[jk]
 * <p>
 * 　　请你帮助金明设计一个满足要求的购物单。
 * <p>
 * <p>
 * <p>
 * <p>
 * 二、分组的背包问题
 * 有 N 组物品和一个容量是 V 的背包。
 * 每组物品有若干个，同一组内的物品最多只能选一个。
 * 每件物品的体积是 w,价值是v
 * 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
 * 输出最大价值。
 * <p>
 * 分析：
 * 依旧以01背包问题思路，
 * 假设选取第i件物品时，本质是选取特定组的物品，而一个组有s个物品，则该组有s+1种选择：选0个～选s个
 * 从里面选取最优解
 * dp[g][j]=max{dp[g-1][j],max{dp[g-1][j-w[i]]+v[i] for s, 1 < i < s}}
 */
public class PackageTest {

    //分组背包问题
    @Test
    public void groupPackage() {
        String[][] group = { //分组物品编号
                {"g11", "g12", "g13", "g14"},
                {"g21", "g22", "g23", "g24"},
                {"g31", "g32", "g33", "g34"},
                {"g41", "g42", "g43", "g44"},
        };

        int[][] weight = { //分组物体积
                {3, 2, 3, 4},
                {1, 2, 3, 4},
                {1, 2, 1, 4},
                {1, 2, 3, 4}
        };

        int[][] value = { //分组物品价值
                {1, 2, 3, 7},
                {1, 5, 3, 4},
                {2, 2, 3, 4},
                {1, 6, 3, 4}
        };
        int c = 10;//限制重量
        int[][] dp = new int[group.length + 1][c + 1];

        for (int g = 1; g < group.length + 1; g++) {
            for (int j = 0; j < c + 1; j++) {
                //dp[g][j]=max{dp[g-1][j],max{dp[g-1][j-w[i]]+v[i] for s, 1 < i < s}}
                int maxGi = 0;
                for (int k = 0; k < group[g - 1].length && j >= weight[g - 1][k]; k++) {
                    maxGi = Math.max(maxGi, dp[g - 1][j - weight[g - 1][k]] + value[g - 1][k]);
                }
                dp[g][j] = Math.max(dp[g - 1][j], maxGi);
            }
        }


        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }

    }


    //金明的预算方案
    @Test
    public void budget(){

    }

}
